var debug = require('debug')('stacks'),
    net = require('net'),
    actorify = require('actorify'),
    async = require('async');

var stacks = new (function Stacks() {
  /**
   * stacks can either be a server or a client
   */
  this._server = null,
  this._client = null;

  debug('stacks init');

  /**
   * create a stacks server to listen for client connections
   *
   * @api public
   * @param <Number> port
   * @param <Function> callback
   */
  this.listen = function listen(port, callback) {
    debug('stacks.listen');

    if (this._server) {
      console.warn('WARNING: listen() has already been called on this instance of stacks... overwriting');
    }
    
    this._server = new StacksServer();
    this._server.listen(port, callback);
  };

  /**
   * make a request to stacks
   * 
   * @api public
   * @param <String> type
   * @param <Mixed> body
   * @param <Object> options
   * @param <Function> callback
   */
  this.request = function request(type, body, options, callback) {
    debug('stacks.request');

    if (this._server) {
      this._server.request(type, body, options, callback);
    } else {
      console.error(new Error('This stacks instance is not a server, and cannot make requests'));
    }
  };

  /**
   * create a stacks client to connect to a stacks server
   * 
   * @api public
   * @param <Mixed> server
   * @param <Function> callback
   */
  this.connect = function connect(server, callback) {
    debug('stacks.connect');

    if (this._client) {
      console.warn('WARNING: connect() has already been called on this instance of stacks... overwriting');
    }
    
    this._client = new StacksClient();
    this._client.connect(server, callback);
    this.disconnect = this._client.disconnect;
  };

  return this;
});

/**
 * stacks client object prototype
 *
 * @api private
 */
function StacksClient() {
  var client = {};
  client._actor = null;
  client._connection = null;
  client._queues = {};

  debug('new instance of StacksClient');

  /**
   * connect to server
   * 
   * @api public
   * @param <Mixed> server
   * @param <Function> callback
   */
  client.connect = function connect(server, callback) {
    debug('stacks client connect...');

    client._connection = net.connect(server, function() {
      debug('stacks client connected to stacks server');

      client._actor = actorify(client._connection);

      /**
       * handle stacks request of type |type| with worker |worker|
       * allow |concurrency| concurrent workers
       *
       * @api public
       * @param <String> type
       * @param <Function> worker
       * @param <Number> concurrency
       */
      client.on = function on(type, worker, concurrency) {
        debug('create queue for requests of type: ', type);

        client._queues[type] = async.queue(worker, concurrency);

        client._actor.on(type, function(body, reply) {
          debug('received stacks request of type %s; with body: ', type, body);

          client._queues[type].push(body, reply);
        });
      };

      /**
       * debug messages for socket events
       */
      client._connection.on('error', function(error) {
        debug('socket error: ', error);
      });
      client._connection.on('end', function() {
        debug('socket end');
      });
      client._connection.on('close', function() {
        debug('socket close');
      });
      client._connection.on('timeout', function() {
        debug('socket timeout');
      });

      callback(client);
    });
  };

  /**
   * disconnect stacks client
   *
   * @api public
   */
  client.disconnect = function disconnect() {
    client._connection.end();
    delete stacks._client;
  };

  /**
   * expose public api
   */
  this.connect = client.connect;
  this.disconnect = client.disconnect;
};

/**
 * stacks server object prototype
 *
 * @api private
 */
function StacksServer() {
  var server = {};
  server.backupStacks = [];
  server.clients = {};
  server.requestNumber = 0;

  debug('new instance of StacksServer');

  /**
   * server connection handler
   * 
   * @api private
   * @param <Socket> sock
   */
  server.connectionHandler = function serverConnectionHandler(sock) {
    var actor = actorify(sock),
        clientKey = actor.id,
        handleSocketClose;

    debug('client with key %s has connected', clientKey);
    debug('actor', actor);

    /**
     * handle socket close
     */
    handleSocketClose = function handleSocketClose() {
      var removedClient = server.clients[clientKey];
      debug('client with key %s has disconnected', clientKey);

      delete server.clients[clientKey];
      debug('deleted client with key %s', clientKey);

      /**
       * request (again) any pending requests on disconnected client
       */
      for (requestNumber in removedClient.pendingRequests) {
        debug('request request number %s again', requestNumber);

        var thisRequest = removedClient.pendingRequests[requestNumber];
        server.request(thisRequest.type, thisRequest.body, thisRequest.callback);
      }

    };

    /**
     * on sock 'error' or 'close', handle socket close
     */
    sock.on('error', function(error) {
      console.error('error: ', error);
      return handleSocketClose;
    });
    sock.on('close', handleSocketClose);

    /**
     * add new client
     */
    server.clients[clientKey] = {
      actor: actor,
      pendingRequests: {}
    };

    /**
     * request any requests from backup stacks
     */
    for (i in server.backupStacks) {
      var thisRequest = server.backupStacks[i];

      debug('request %s request from backup stacks', thisRequest.type);

      server.request(thisRequest.type, thisRequest.body, thisRequest.callback);

      delete server.backupStacks[i];
    }
  };

  /**
   * listen for client connections
   *
   * @api private
   * @param <Number> port
   * @param <Function> callback
   */
  server.listen = function listen(port, callback) {
    var connectionListener;

    debug('stacks server listen...');

    if (typeof callback != 'function') {
      callback = function() {};
    }

    connectionListener = net.createServer(server.connectionHandler);

    connectionListener.listen(port, function() {
      debug('stacks server listening on port ', port);

      callback();
    });

  };

  /**
   * get the key (actor.id) of the next client to request
   * uses round-robin distribution
   * 
   * @api private
   */
  server.getNextClientKey = function getNextClientKey() {
    var clientKeys = Object.keys(server.clients);
        clientCount = clientKeys.length,
        nextClientKey = clientKeys[server.requestNumber % clientCount];

    debug('get next client key. nextClientKey: ', nextClientKey);

    return nextClientKey;
  };

  /**
   * get a client by key (actor.id)
   *
   * @api private
   * @param key
   */
  server.getClient = function getClient(key) {

    /**
     * send a request to this client,
     * add it to this client's pending requests,
     * when it calls back, remove it from this client's pending requests
     * call back with error & response body
     */
    this.clientRequest = function clientRequest(type, body, options, callback) {
      debug('client request. _requestNumber: ', options._requestNumber);

      server.clients[key].pendingRequests[options._requestNumber] = { 
        type: type,
        body: body,
        callback: callback
      };

      server.clients[key].actor.send(type, body, function(error, response) {
        debug('client request finished. _requestNumber: ', options._requestNumber);

        delete server.clients[key].pendingRequests[options._requestNumber];

        debug('client with key %s\'s pendingRequests: ', key, server.clients[key].pendingRequests);

        callback(error, response);
      });
    };

    return this;
  };

  /**
   * make a request to stacks
   * 
   * @api private
   * @param <String> type
   * @param <Mixed> body
   * @param <Object> options
   * @param <Function> callback
   */
  server.request = function serverRequest(type, body, options, callback) {
    debug('stacks.server.request');

    /**
     * handle options
     * if typeof options is function, no options were passed
     */
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    /** 
     * handle options.maxRetries
     * if undefined, default to 3
     */
    if (typeof options.maxRetries === 'undefined') {
      options.maxRetries = 3;
    }
    
    /**
     * handle options._retrySequence
     * if undefined, default to 0
     */
    if (typeof options._retrySequence === 'undefined') {
      options._retrySequence = 0;
    }

    /**
     * set this request's options._requestNumber; increment _requestNumber
     */
    options._requestNumber = server.requestNumber++;

    /**
     * if no clients are connected, add request to backup stacks and return
     */
    if (Object.keys(server.clients).length < 1) {
      debug('no clients connected, backing up request');
      
      server.backupStacks.push({
        type: type,
        body: body,
        callback: callback
      });
      return;
    }

    /**
     * if options._retrySequence++ >= options.maxRetries, 
     *  request
     * else
     *  callback with new error
     */
    if (options._retrySequence++ <= options.maxRetries) {
      server.getClient(server.getNextClientKey()).clientRequest(type, body, options, function(error, response) {
        debug('request finished. _requestNumber: ', options._requestNumber);

        if (error) {
          debug('request with _requestNumber %s resulted in error: ', options._requestNumber, error);

          server.request(type, body, options, callback);
        } else {
          debug('request with _requestNumber %s had response: ', options._requestNumber, response);

          callback(error, response);
        }
      });
    } else {
      callback(new Error(type +' request failed after max retry attempts'), null);
    }

  };

  /**
   * expose public api
   */
  this.listen = server.listen;
  this.request = server.request;

  return this;
};

/**
 * export api
 */
module.exports = stacks;
